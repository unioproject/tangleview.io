const TangleGlumb=($container,config={})=>{const LOG=!1,CONFIG={SPRINGLENGTH:10,SPRINGCOEFF:1e-4,GRAVITY:-4,DRAGCOEFF:.02,TIMESTEP:22,PAUSE_RENDERING:!1,FORCE:{x:0,y:.05},CIRCLE_SIZE:30,REMOVE_LONLY_AFTER_S:30,REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH:.03,MAX_CIRCLE_SIZE:80,MAX_NODES:4e3,REMOVE_FLOATING_NODES:!0,SIZE_BY_DEPTH:!1,SIZE_BY_VALUE:!1,SIZE_BY_WEIGHT:!1,REMOVE_OLD_NODES:!1,PIN_OLD_NODES:!0,LIGHT_LINKS:!1,SPAWN_NODE_NEAR_FINAL_POSITION:!0,COLOR_BY_NUMBER:!1,DARK_MODE:!1,STATIC_FRONT:!1,HIGHLIGHT_MULTIPLE_COLOR:14306089,SAME_BUNDLE_COLOR:1214463,LIGHT_LINK_COLOR:572662527,LIGHT_NODE_COLOR:255,LIGHT_NODE_BG_COLOR:16777215,HIGHLIGHT_COLOR_FORWARD:4055312383,HIGHLIGHT_COLOR_BACKWARD:3795711231,MILESTONE_COLOR:15023471,TIP_COLOR:2089150,LINK_COLOR:0,NODE_COLOR:0,NODE_BG_COLOR:0,TITLE:"The Tangle",...config};CONFIG.LINK_COLOR=CONFIG.LIGHT_LINK_COLOR,CONFIG.NODE_COLOR=CONFIG.LIGHT_NODE_COLOR,CONFIG.NODE_BG_COLOR=CONFIG.LIGHT_NODE_BG_COLOR;const Events=(()=>{var topics={},hOP=topics.hasOwnProperty;return{on:(topic,listener)=>{hOP.call(topics,topic)||(topics[topic]=[]);var index=topics[topic].push(listener)-1;return{remove:()=>{delete topics[topic][index]}}},emit:(topic,info)=>{hOP.call(topics,topic)&&topics[topic].forEach(item=>{item(info)})}}})(),tangle=Events;function WebglCircle(size,color,border_size=.5,border_color=parseInt("000000",16)){this.size=size,this.color=color,this.border_size=border_size,this.border_color=border_color,this.confirmed=!1,this.tip=!0}function buildCircleNodeShader(){let webglUtils;const ATTRIBUTES_PER_PRIMITIVE=6,nodesFS=["precision mediump float;","varying vec4 color;","varying vec4 border_color;","varying float border_size;","void main(void) {","   if ((gl_PointCoord.x - 0.5) * (gl_PointCoord.x - 0.5) + (gl_PointCoord.y - 0.5) * (gl_PointCoord.y - 0.5) < 0.25 - border_size) {","     gl_FragColor = color;","   } else if ((gl_PointCoord.x - 0.5) * (gl_PointCoord.x - 0.5) + (gl_PointCoord.y - 0.5) * (gl_PointCoord.y - 0.5) < 0.25) {","     gl_FragColor = border_color;","   } else {","     gl_FragColor = vec4(0);","   }","}"].join("\n"),nodesVS=["attribute vec2 a_vertexPos;","attribute vec4 a_customAttributes;","uniform vec2 u_screenSize;","uniform mat4 u_transform;","varying vec4 color;","varying vec4 border_color;","varying float border_size;","void main(void) {","   gl_Position = u_transform * vec4(a_vertexPos/u_screenSize, 0, 1);","   gl_PointSize = a_customAttributes[1] * u_transform[0][0];","   float c = a_customAttributes[0];","   color.b = mod(c, 256.0); c = floor(c/256.0);","   color.g = mod(c, 256.0); c = floor(c/256.0);","   color.r = mod(c, 256.0); c = floor(c/256.0); color /= 255.0;","   color.a = 1.0;","   float bc = a_customAttributes[3];","   border_color.b = mod(bc, 256.0); bc = floor(bc/256.0);","   border_color.g = mod(bc, 256.0); bc = floor(bc/256.0);","   border_color.r = mod(bc, 256.0); bc = floor(bc/256.0); border_color /= 255.0;","   border_color.a = 1.0;","   border_size = a_customAttributes[2]/4.0;","}"].join("\n");let program,gl,buffer,locations,utils,nodes=new Float32Array(64),nodesCount=0,canvasWidth,canvasHeight,transform,isCanvasDirty;return{load:function(glContext){gl=glContext,webglUtils=Viva.Graph.webgl(glContext),program=webglUtils.createProgram(nodesVS,nodesFS),gl.useProgram(program),locations=webglUtils.getLocations(program,["a_vertexPos","a_customAttributes","u_screenSize","u_transform"]),gl.enableVertexAttribArray(locations.vertexPos),gl.enableVertexAttribArray(locations.customAttributes),buffer=gl.createBuffer()},position:function(nodeUI,pos){const idx=nodeUI.id;nodes[6*idx]=pos.x,nodes[6*idx+1]=-pos.y,nodes[6*idx+2]=nodeUI.color,nodes[6*idx+3]=nodeUI.size,nodes[6*idx+4]=nodeUI.border_size,nodes[6*idx+5]=nodeUI.border_color},render:function(){gl.useProgram(program),gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,nodes,gl.DYNAMIC_DRAW),isCanvasDirty&&(isCanvasDirty=!1,gl.uniformMatrix4fv(locations.transform,!1,transform),gl.uniform2f(locations.screenSize,canvasWidth,canvasHeight)),gl.vertexAttribPointer(locations.vertexPos,2,gl.FLOAT,!1,6*Float32Array.BYTES_PER_ELEMENT,0),gl.vertexAttribPointer(locations.customAttributes,4,gl.FLOAT,!1,6*Float32Array.BYTES_PER_ELEMENT,8),gl.drawArrays(gl.POINTS,0,nodesCount)},updateTransform:function(newTransform){transform=newTransform,isCanvasDirty=!0},updateSize:function(newCanvasWidth,newCanvasHeight){canvasWidth=newCanvasWidth,canvasHeight=newCanvasHeight,isCanvasDirty=!0},createNode:function(node){nodes=webglUtils.extendArray(nodes,nodesCount,6),nodesCount+=1},removeNode:function(node){nodesCount>0&&(nodesCount-=1),node.id<nodesCount&&nodesCount>0&&webglUtils.copyArrayPart(nodes,6*node.id,6*nodesCount,6)},replaceProperties:function(replacedNode,newNode){}}}const VVG=(Viva=>{const graph=Viva.Graph.graph(),graphics=Viva.Graph.View.webglGraphics(),layout=Viva.Graph.Layout.forceDirected(graph,{springLength:CONFIG.SPRINGLENGTH,springCoeff:CONFIG.SPRINGCOEFF,gravity:CONFIG.GRAVITY,dragCoeff:CONFIG.DRAGCOEFF,timeStep:CONFIG.TIMESTEP}),renderer=Viva.Graph.View.renderer(graph,{container:document.getElementById("graph"),graphics:graphics,layout:layout}),events=Viva.Graph.webglInputEvents(graphics,graph),circleNode=buildCircleNodeShader();return graphics.setNodeProgram(circleNode),graphics.node(()=>new WebglCircle(10,0,0,0)),renderer.run(),{graph:graph,graphics:graphics,layout:layout,renderer:renderer,events:events}})(Viva),Loading=(($,$container)=>{$container.insertAdjacentHTML("beforeend",' <div class="loader-wrapper">\n                <div class="loader"></div>\n                <div class="progress"></div>\n            </div>');const $wrapper=$(".loader-wrapper"),$progress=$(".loader-wrapper .progress");let loading=!0;function start(){loading=!0,$wrapper.show()}function stop(){loading&&($wrapper.hide(),$progress.text(""),loading=!1)}function progress(i,min=0,max=1){if(i>=max)return $wrapper.hide(),void $progress.text("");$wrapper.show(),$progress.text(`${(i/(max-min)*100).toFixed(1)}%`)}return{start:start,stop:stop,progress:progress}})($,$container);Loading.start();const Iterators=(VVG=>{function dfsDirectedIterator(node,cb,up,cbLinks=!1,seenNodes=[]){seenNodes.push(node);let pointer=0;for(;seenNodes.length>pointer;){const node=seenNodes[pointer++];if(cb(node))return!0;for(const link of node.links)cbLinks&&cbLinks(link),up||link.toId!==node.id||seenNodes.includes(VVG.graph.getNode(link.fromId))?up&&link.fromId===node.id&&!seenNodes.includes(VVG.graph.getNode(link.toId))&&seenNodes.push(VVG.graph.getNode(link.toId)):seenNodes.push(VVG.graph.getNode(link.fromId))}}function bfsDirectedIterator(node,cb,up,cbLinks=!1,seenNodes=[]){let pointer=0;for(seenNodes.push(node);seenNodes.length>pointer;){const node=seenNodes[pointer++];if(cb(node))return!0;const links=node.links;for(let i=0;i<links.length;i++){const link=links[i];cbLinks&&cbLinks(link),!up&&link.toId===node.id&&seenNodes.indexOf(VVG.graph.getNode(link.fromId))<0?seenNodes.push(VVG.graph.getNode(link.fromId)):up&&link.fromId===node.id&&seenNodes.indexOf(VVG.graph.getNode(link.toId))<0&&seenNodes.push(VVG.graph.getNode(link.toId))}}}function bfsIterator(node,cb,cbLinks=!1,seenNodes=[]){let pointer=0;for(seenNodes.push(node);seenNodes.length>pointer;){const node=seenNodes[pointer++];if(cb(node))return!0;for(const link of node.links)cbLinks&&cbLinks(link),seenNodes.includes(VVG.graph.getNode(link.fromId))||seenNodes.push(VVG.graph.getNode(link.fromId)),seenNodes.includes(VVG.graph.getNode(link.toId))||seenNodes.push(VVG.graph.getNode(link.toId))}}function iterateAllConnectedNodes(node,cb,cbLinks,seenNodes){bfsIterator(node,cb,cbLinks,seenNodes)}return{dfsDirectedIterator:dfsDirectedIterator,bfsDirectedIterator:bfsDirectedIterator,bfsIterator:bfsIterator,iterateAllConnectedNodes:iterateAllConnectedNodes}})(VVG),Graphs=((CONFIG,VVG,Iterators)=>{const smallGraphsQueue={};let nodeNumber=0;function addNode(nodeId,nodeNum){if(nodeNumber=nodeNum,CONFIG.REMOVE_FLOATING_NODES)for(const link of VVG.graph.getNode(nodeId).links)void 0!==smallGraphsQueue[link.toId]&&delete smallGraphsQueue[link.toId];smallGraphsQueue[nodeId]=Date.now(),VVG.graph.getNodesCount()-100>CONFIG.MAX_NODES&&(CONFIG.REMOVE_OLD_NODES&&removeOldNodes(),CONFIG.PIN_OLD_NODES&&pinOldNodes());const links=VVG.graph.getNode(nodeId).links;(isInDeleteQueue(links[0].toId)||links[1]&&isInDeleteQueue(links[1].toId))&&Iterators.iterateAllConnectedNodes(VVG.graph.getNode(nodeId),node=>{deleteQueue.indexOf(node.id)>=0&&deleteQueue.splice(deleteQueue.indexOf(node.id),1)})}function isInDeleteQueue(nodeId){return deleteQueue.indexOf(nodeId)>=0}function removeSmallGraphs(){const numberOfNodes=VVG.graph.getNodesCount();LOG&&console.log(Object.keys(smallGraphsQueue).length),Object.keys(smallGraphsQueue).length*CONFIG.REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH>2&&updateGraphsList();for(const nodeId in smallGraphsQueue){if(Date.now()-smallGraphsQueue[nodeId]<=1e3*CONFIG.REMOVE_LONLY_AFTER_S)continue;let lastTime=0,lastTimeId=nodeId;const nodes=[];if(Iterators.iterateAllConnectedNodes(VVG.graph.getNode(nodeId),node=>(void 0!==smallGraphsQueue[node.id]&&(lastTime<smallGraphsQueue[node.id]&&(lastTimeId=node.id,lastTime=smallGraphsQueue[node.id]),delete smallGraphsQueue[node.id]),nodes.push(node),nodes.length>=CONFIG.REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH*numberOfNodes)),smallGraphsQueue[lastTimeId]=lastTime,nodes.length<CONFIG.REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH*numberOfNodes&&Date.now()-lastTime>1e3*CONFIG.REMOVE_LONLY_AFTER_S){LOG&&console.log("mesh of size: "+nodes.length+" is smaller than "+100*CONFIG.REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH+"% of the total node count: "+CONFIG.REMOVE_SMALLER_THAN_PERCENTAGE_OF_TOTAL_MESH*numberOfNodes);for(const node of nodes)addToDeleteQueue(node.id)}}LOG&&console.log(Object.keys(smallGraphsQueue).length)}const deleteQueue=[];function addToDeleteQueue(nodeId){deleteQueue.indexOf(nodeId)<0&&deleteQueue.push(nodeId),1==deleteQueue.length&&processDeleteQueue()}const DELETE_QUEUE_INTERVAL=50;let deleteNodeCount=0;function processDeleteQueue(){deleteQueue.length>0&&(LOG&&console.log("delete queue len",deleteQueue.length),setTimeout(()=>{do{const nodeToDelete=deleteQueue.shift(),selectedNode=Selection.getSelectedNode();if(!nodeToDelete||selectedNode&&nodeToDelete==selectedNode.id)LOG&&console.log("not deleted");else{smallGraphsQueue[nodeToDelete]&&delete smallGraphsQueue[nodeToDelete];for(const link of VVG.graph.getNode(nodeToDelete).links)smallGraphsQueue[link.toId==nodeToDelete?link.fromId:link.toId]=Date.now();VVG.graph.removeNode(nodeToDelete),deleteNodeCount++}}while(deleteQueue.length>200);processDeleteQueue()},DELETE_QUEUE_INTERVAL))}function updateGraphsList(){for(const nodeId in smallGraphsQueue){let lastTime=0,lastTimeId=nodeId;LOG&&console.log("iter"),Iterators.iterateAllConnectedNodes(VVG.graph.getNode(nodeId),node=>{void 0!==smallGraphsQueue[node.id]&&(lastTime<smallGraphsQueue[node.id]&&(lastTimeId=node.id,lastTime=smallGraphsQueue[node.id]),delete smallGraphsQueue[node.id])}),smallGraphsQueue[lastTimeId]=lastTime}}function getNodePerGraph(){return updateGraphsList(),smallGraphsQueue}function iterateAllNodes(cb=!1,linkCb=!1){if(linkCb&&!cb)VVG.graph.forEachLink(linkCb);else if(cb&&!linkCb)VVG.graph.forEachNode(cb);else if(cb&&linkCb){const nodes=getNodePerGraph();for(const nodeId in nodes)Iterators.iterateAllConnectedNodes(VVG.graph.getNode(nodeId),cb,linkCb)}}function removeOldNodes(){const count=VVG.graph.getNodesCount()-deleteQueue.length,toDeleteCount=count-CONFIG.MAX_NODES,maxNumberToDelete=nodeNumber-toDeleteCount;let numberToDelete=toDeleteCount;VVG.graph.forEachNode(node=>{if(node.number<=maxNumberToDelete&&(addToDeleteQueue(node.id),LOG&&console.log("removed node",node.id),--numberToDelete<=1))return!0})}function isDeleteQueueEmpty(){return 0==deleteQueue.length}let highestPinnedNumber=0;function pinOldNodes(){const delFraction=deleteNodeCount/nodeNumber,unpinnedNodes=(nodeNumber-highestPinnedNumber)*(1-delFraction);if(unpinnedNodes>CONFIG.MAX_NODES+150){const toPinCount=unpinnedNodes-CONFIG.MAX_NODES,maxNumberToPin=(highestPinnedNumber+toPinCount)*(1+delFraction);let numberToPin=toPinCount;VVG.graph.forEachNode(node=>{if(node.number<=maxNumberToPin&&(VVG.layout.pinNode(node,!0),node.number>highestPinnedNumber&&(LOG&&console.log("pinned node",node.id),--numberToPin<=1)))return LOG&&console.log("breaking -----------"),!0}),highestPinnedNumber+=toPinCount}}function unpinOldNodes(){highestPinnedNumber=0,VVG.graph.forEachNode(node=>{VVG.layout.pinNode(node,!1)})}return{addNode:addNode,removeSmallGraphs:removeSmallGraphs,getNodePerGraph:getNodePerGraph,iterateAllNodes:iterateAllNodes,isDeleteQueueEmpty:isDeleteQueueEmpty,unpinOldNodes:unpinOldNodes}})(CONFIG,VVG,Iterators);setInterval(()=>{CONFIG.REMOVE_FLOATING_NODES&&Graphs.removeSmallGraphs()},1e3*CONFIG.REMOVE_LONLY_AFTER_S);const Styles=(Graphs=>{const filters=[];let cacheDirty=!1;function clearCache(){cacheDirty=!0,update()}function update(node){if(node)for(const filter of filters)filter(node);else cacheDirty&&(cacheDirty=!1,Graphs.iterateAllNodes(node=>{for(const filter of filters)filter(node)}))}function add(filter){return cacheDirty=!0,filters.push(filter),update(),filter}function remove(filter){cacheDirty=!0,filters.splice(filters.indexOf(filter),1),update()}return{add:add,remove:remove,update:update,clearCache:clearCache}})(Graphs),Color=((CONFIG,VVG)=>{function colorNode(node){const ui=VVG.graphics.getNodeUI(node.id);ui.border_color=CONFIG.NODE_COLOR>>>8,node.tip?(ui.color=CONFIG.TIP_COLOR,ui.border_size=.6):node.milestone?(ui.border_size=.6,ui.color=CONFIG.MILESTONE_COLOR):node.confirmed?(ui.border_size=1,ui.color=CONFIG.NODE_BG_COLOR):(ui.border_size=.8,ui.color=CONFIG.NODE_BG_COLOR)}function colorLink(link){const ui=VVG.graphics.getLinkUI(link.id);ui.color=CONFIG.LINK_COLOR}return{colorNode:colorNode,colorLink:colorLink}})(CONFIG,VVG);Styles.add(Color.colorNode),Styles.add(node=>{const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.size=CONFIG.CIRCLE_SIZE});const Format=(()=>{const ranges=[{divider:1e18,suffix:"P"},{divider:1e15,suffix:"E"},{divider:1e12,suffix:"T"},{divider:1e9,suffix:"G"},{divider:1e6,suffix:"M"},{divider:1e3,suffix:"k"}];function formatNumber(n){for(let i=0;i<ranges.length;i++)if(Math.abs(n)>=ranges[i].divider)return(n/ranges[i].divider).toFixed(2)+ranges[i].suffix;return n.toFixed(2)}return{formatNumber:formatNumber}})(),UI=($container=>{const mainLeftTop=`<div id="title">\n            <h1>${CONFIG.TITLE} <small id="network"></small></h1>\n            <div class="legend">\n                <span class="circle" id="tip"></span> tip <br>\n                <span class="circle" id="milestone"></span> milestone <br>\n                <span class="circle" id="node"></span> transaction <br>\n                <span class="circle" id="confirmed"></span> confirmed <br>\n                <br> select a transaction to view<br>\n                <span class="circle" id="confirmed-by-tx"></span> <span id="confirmed-by-count"></span> confirmed by tx<br>\n                <span class="circle" id="confirming-tx"></span> <span id="confirming-count"></span> confirming tx<br>\n                <span class="circle" id="bundle"></span> same bundle <br>\n            </div>\n            <div class="filter">\n                <br> enter a tx hash<br>\n                <input id="hash-input" type="text" name="hash" placeholder="hash">\n                <span id="hash-info"></span>\n                <br> enter a tag<br>\n                <input id="tag-input" type="text" name="tag" placeholder="tag or regex">\n                <span id="tag-info"></span>\n                <br> enter a bundle-hash<br>\n                <input id="bundle-hash-input" type="text" name="bundle-hash" placeholder="bundle-hash">\n                <span id="bundle-hash-info"></span>\n            </div>\n        </div>`;return $container.insertAdjacentHTML("beforeend",mainLeftTop),{setNetworkName:name=>document.getElementById("network").innerText=name}})($container),Selection=((VVG,Iterators,Format,$)=>{let hoveredNode=null,selectedNode=null,activeNode=null;function hasChildren(node){let children=!1;return VVG.graph.forEachLinkedNode(node.id,()=>(children=!0,!0),!0),children}function selectNodeAndChildren(node){const nodeUI=VVG.graphics.getNodeUI(node.id);if(!nodeUI)return;nodeUI.size=1.6*CONFIG.CIRCLE_SIZE,VVG.layout.pinNode(node,!0);const seenNodesBackwards=[],seenNodesForward=[],bh=(node.data||{}).bundle_hash;return Iterators.dfsDirectedIterator(node,node=>{const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.border_color=CONFIG.HIGHLIGHT_COLOR_BACKWARD>>>8,bh&&bh===((node||{}).data||{}).bundle_hash&&(nodeUI.border_color=CONFIG.SAME_BUNDLE_COLOR)},!0,link=>{const linkUI=VVG.graphics.getLinkUI(link.id);linkUI.color=CONFIG.HIGHLIGHT_COLOR_BACKWARD},seenNodesBackwards),Iterators.dfsDirectedIterator(node,node=>{const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.border_color=CONFIG.HIGHLIGHT_COLOR_FORWARD>>>8,bh&&bh===((node||{}).data||{}).bundle_hash&&(nodeUI.border_color=CONFIG.SAME_BUNDLE_COLOR)},!1,link=>{const linkUI=VVG.graphics.getLinkUI(link.id);linkUI.color=CONFIG.HIGHLIGHT_COLOR_FORWARD},seenNodesForward),hasChildren(node)||(VVG.graphics.getNodeUI(node.id).border_color=CONFIG.HIGHLIGHT_COLOR_BACKWARD>>>8),{seenNodesBackwards:seenNodesBackwards,seenNodesForward:seenNodesForward}}function deselectNodeAndChildren(node){const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI&&(nodeUI.border_color=CONFIG.NODE_COLOR>>>8,Styles.update(node),VVG.layout.pinNode(node,!1),Iterators.dfsDirectedIterator(node,node=>Styles.update(node),!0,link=>Color.colorLink(link)),Iterators.dfsDirectedIterator(node,node=>Styles.update(node),!1,link=>Color.colorLink(link)))}function recursivelyColor(node,nodeColor,linkColor,backwards=!1,seenNodes=[]){const nodeId=node.id,links=node.links;if(seenNodes.includes(nodeId))return;seenNodes.push(nodeId);const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.border_color=nodeColor>>>8;const bh=((VVG.graph.getNode(seenNodes[0])||{}).data||{}).bundle_hash;bh&&bh===((node||{}).data||{}).bundle_hash&&(nodeUI.border_color=CONFIG.SAME_BUNDLE_COLOR);for(let i=0;i<links.length;i++){const link=links[i];if(backwards&&link.toId===nodeId){recursivelyColor(VVG.graph.getNode(link.fromId),nodeColor,linkColor,backwards,seenNodes);const linkUI=VVG.graphics.getLinkUI(link.id);linkUI.color=linkColor}else if(!backwards&&link.fromId===nodeId){recursivelyColor(VVG.graph.getNode(link.toId),nodeColor,linkColor,backwards,seenNodes);const linkUI=VVG.graphics.getLinkUI(link.id);linkUI.color=linkColor}}}function selectNode(node){selectedNode&&deselectNodeAndChildren(selectedNode),hoveredNode&&deselectNodeAndChildren(hoveredNode),node?(selectedNode=node,activeNode=node):(selectedNode=null,activeNode=hoveredNode),updateActiveNodeSelection()}function hoverNode(node){selectedNode&&deselectNodeAndChildren(selectedNode),hoveredNode&&deselectNodeAndChildren(hoveredNode),node?(hoveredNode=node,activeNode=node):(hoveredNode=null,activeNode=selectedNode),updateActiveNodeSelection()}const $txInfoContainer=document.createElement("div");$txInfoContainer.setAttribute("id","tx-info"),$container.appendChild($txInfoContainer);const $confirmedByCount=$("#confirmed-by-count"),$confirmingCount=$("#confirming-count");function updateActiveNodeSelection(){if(activeNode){const linkedNodes=selectNodeAndChildren(activeNode);if(void 0!==activeNode.data){const node=Selection.getActiveNode();$txInfoContainer.innerHTML="value: "+Format.formatNumber(+node.data.value)+"i<br>tx tag: "+node.data.tag+"<br>tx hash: "+node.data.hash+"<br>bundle hash ("+node.data.current_index+"|"+node.data.last_index+"): "+node.data.bundle_hash+"<br>"}$confirmingCount.text(linkedNodes.seenNodesForward.length-1),$confirmedByCount.text(linkedNodes.seenNodesBackwards.length-1)}else $txInfoContainer.innerHTML="",$confirmingCount.text(""),$confirmedByCount.text("");VVG.renderer.rerender()}function getActiveNode(){return activeNode}function getSelectedNode(){return selectedNode}let mouseOverNode=null;VVG.events.mouseEnter(function(node){document.body.style.cursor="pointer",hoverNode(node),mouseOverNode=node}).mouseLeave(function(){document.body.style.cursor="default",hoverNode(),mouseOverNode=null});let isDragging=!1;return $("canvas").mousedown(function(){isDragging=!1}).mousemove(function(){isDragging=!0}).mouseup(function(){const wasDragging=isDragging;isDragging=!1,LOG&&console.log(wasDragging),wasDragging||selectNode(mouseOverNode)}),{selectNode:selectNode,hoverNode:hoverNode,updateActiveNodeSelection:updateActiveNodeSelection,getActiveNode:getActiveNode,getSelectedNode:getSelectedNode}})(VVG,Iterators,Format,$),Viewport=(VVG=>{function zoom(desiredScale,currentScale,tries){(tries=tries||0)>30||Math.abs(desiredScale-currentScale)<.01||(desiredScale<currentScale?zoom(desiredScale,currentScale=VVG.renderer.zoomOut(),++tries):desiredScale>currentScale&&zoom(desiredScale,currentScale=VVG.renderer.zoomIn(),++tries))}function fit(){const graphRect=VVG.layout.getGraphRect();LOG&&console.log(graphRect);const graphSize=Math.min(graphRect.x2-graphRect.x1,graphRect.y2-graphRect.y1),screenSize=Math.min(document.body.clientWidth,document.body.clientHeight),desiredScale=screenSize/graphSize;LOG&&console.log(desiredScale),VVG.renderer.moveTo(0,0),zoom(desiredScale,VVG.renderer.zoomOut())}function moveTo(x,y){VVG.renderer.moveTo(x,y)}return{zoom:zoom,fit:fit,moveTo:moveTo}})(VVG);$("body").keypress(e=>{if(event.ctrlKey&&"f"===event.key)return e.preventDefault(),Viewport.fit(),!1}),Viewport.zoom(.1,1);const Filter=((VVG,Selection,$,Viewport)=>{function selectNodeByHash(hash){$("#hash-input").val(hash);const nodeId=hash;if(VVG.graph.getNode(nodeId)){const pos=VVG.layout.getNodePosition(nodeId);Viewport.moveTo(pos.x,pos.y),Selection.selectNode(VVG.graph.getNode(nodeId)),$("#hash-info").text("")}else $("#hash-info").text("hash not found (yet)")}function highlightNode(node,color){const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.border_color=color,nodeUI.size=1.4*CONFIG.CIRCLE_SIZE}$("#hash-input").keypress(function(e){const key=e.which;if(13==key||"Enter"===event.key)return e.preventDefault(),selectNodeByHash($("#hash-input").val().trim()),!1});let tag_filter=!1;function selectNodesByTag(tag){$("#tag-input").val(tag),tag_filter&&(Styles.remove(tag_filter),tag_filter=!1);const tagRegex=tag;if(0==tagRegex.length)return;const R=new RegExp(tagRegex,"i");tag_filter=Styles.add(node=>{node.data&&node.data.tag.match(R)&&highlightNode(node,CONFIG.HIGHLIGHT_MULTIPLE_COLOR)})}$("#tag-input").keypress(function(e){const key=e.which;if(13==key||"Enter"===event.key)return e.preventDefault(),selectNodesByTag($("#tag-input").val().trim()),!1});let bundle_hash_filter=!1;function selectNodesByBundle(bundle_hash){bundle_hash_filter&&(Styles.remove(bundle_hash_filter),bundle_hash_filter=!1),0!=bundle_hash.length&&(bundle_hash_filter=Styles.add(node=>{node.data&&node.data.bundle_hash===bundle_hash&&highlightNode(node,CONFIG.SAME_BUNDLE_COLOR)}))}return $("#bundle-hash-input").keypress(function(e){const key=e.which;if(13==key||"Enter"===event.key){e.preventDefault();const bundle_hash=$("#bundle-hash-input").val().trim();return selectNodesByBundle(bundle_hash),!1}}),{selectNodeByHash:selectNodeByHash,selectNodesByTag:selectNodesByTag,selectNodesByBundle:selectNodesByBundle}})(VVG,Selection,$,Viewport),ImageSVGExport=((Graphs,VVG)=>({init:()=>{function getNode(n,v){n=document.createElementNS("http://www.w3.org/2000/svg",n);for(const p in v)n.setAttributeNS(null,p.replace(/[A-Z]/g,function(m){return"-"+m.toLowerCase()}),v[p]);return n}function createSVG(){function getGraphBoundingBox(){const bbx={x1:Number.MAX_VALUE,x2:Number.MIN_VALUE,y1:Number.MAX_VALUE,y2:Number.MIN_VALUE};return Graphs.iterateAllNodes(n=>{const pos=VVG.layout.getNodePosition(n.id);pos.x>bbx.x2&&(bbx.x2=pos.x),pos.x<bbx.x1&&(bbx.x1=pos.x),pos.y>bbx.y2&&(bbx.y2=pos.y),pos.y<bbx.y1&&(bbx.y1=pos.y)}),bbx}const bbx=getGraphBoundingBox(),svg=getNode("svg",{width:bbx.x2,height:bbx.y2,viewBox:bbx.x1+" "+bbx.y1+" "+(bbx.x2-bbx.x1)+" "+(bbx.y2-bbx.y1)});function addCircle(x,y,radius,stroke,color,strokeColor){const r=getNode("circle",{cx:x,cy:y,r:radius,strokeWidth:stroke*radius,fill:"#"+color.toString(16),stroke:"#"+strokeColor.toString(16)});svg.appendChild(r)}function addLink(x1,y1,x2,y2,strokeWidth,strokeColor){const r=getNode("line",{x1:x1,x2:x2,y1:y1,y2:y2,strokeWidth:strokeWidth,stroke:"#"+strokeColor.toString(16)});svg.appendChild(r)}Graphs.iterateAllNodes(!1,link=>{const pos=VVG.layout.getLinkPosition(link.id),ui=VVG.graphics.getLinkUI(link.id);addLink(pos.from.x,pos.from.y,pos.to.x,pos.to.y,3,ui.color>>>8)}),Graphs.iterateAllNodes(node=>{const pos=VVG.layout.getNodePosition(node.id),nodeUI=VVG.graphics.getNodeUI(node.id);addCircle(pos.x,pos.y,.45*nodeUI.size,nodeUI.border_size,nodeUI.color,nodeUI.border_color)});const svgBlob=new Blob([svg.outerHTML],{type:"image/svg+xml;charset=utf-8"}),svgUrl=URL.createObjectURL(svgBlob),downloadLink=document.createElement("a");downloadLink.href=svgUrl,downloadLink.download="tangle.svg",document.body.appendChild(downloadLink),downloadLink.click(),document.body.removeChild(downloadLink)}const $button=$('<button style="\n                                    position: fixed;\n                                    top: 10px;\n                                    left: 10px;\n                                    ">capture SVG</button>').on("click",()=>{createSVG()});$("body").append($button)}}))(Graphs,VVG),UrlParams=((Filter,ImageSVGExport)=>{function initAfterNodesAdded(){if(urlParams.has("hash")?Filter.selectNodeByHash(urlParams.get("hash")):urlParams.has("tag")?Filter.selectNodesByTag(urlParams.get("tag")):urlParams.has("bundle")&&Filter.selectNodesByBundle(urlParams.get("bundle")),urlParams.has("tool")){const script=document.createElement("script");script.src=urlParams.get("tool")+".js",document.head.appendChild(script)}urlParams.has("clean")&&$("div").not("#graph").hide(),urlParams.has("svg")&&ImageSVGExport.init()}return{initAfterNodesAdded:initAfterNodesAdded}})(Filter,ImageSVGExport),App=((VVG,tangle,Color,Styles,Graphs,Iterators,UrlParams,Loading)=>{let nodeNumber=0,pinnedNodesqueue=[null,null,null,null,null,null,null,null,null,null],pinnedNodesPointer=0;function addNode(data){LOG&&console.log(data);let tip=!0,node=VVG.graph.getNode(data.hash);if(node||data.transaction_branch&&data.transaction_trunk&&data.hash){if(CONFIG.SPAWN_NODE_NEAR_FINAL_POSITION&&VVG.graph.beginUpdate(),!node){const spawnPosition=CONFIG.STATIC_FRONT?{x:100*Math.random(),y:100*Math.random()}:void 0;!(node=VVG.graph.addNode(data.hash,data,spawnPosition)).number&&CONFIG.STATIC_FRONT&&(VVG.layout.pinNode(node,!0),pinnedNodesqueue[pinnedNodesPointer]=node,pinnedNodesPointer=++pinnedNodesPointer%10,pinnedNodesqueue[pinnedNodesPointer]&&VVG.layout.pinNode(pinnedNodesqueue[pinnedNodesPointer],!1))}data.transaction_branch&&!node.links.some(link=>link.fromId===data.transaction_branch)&&VVG.graph.addLink(data.transaction_branch,data.hash),data.transaction_trunk&&!node.links.some(link=>link.fromId===data.transaction_trunk)&&VVG.graph.addLink(data.transaction_trunk,data.hash),CONFIG.SPAWN_NODE_NEAR_FINAL_POSITION&&VVG.graph.endUpdate();for(const link of node.links)Color.colorLink(link);node.milestone=data.milestone,node.tip=!0,node.number=node.number||++nodeNumber;for(const link of VVG.graph.getNode(data.hash).links){const node=VVG.graph.getNode(link.fromId),nodeto=VVG.graph.getNode(link.toId);node.number=node.number||++nodeNumber,node.tip=!1,node.confirmed=nodeto.milestone||data.confirmed||nodeto.confirmed,Styles.update(node)}Styles.update(node),Graphs.addNode(data.hash,nodeNumber),node.milestone&&processNewMilestone(data.hash)}else console.warn("new node must contail all required fields [branch,trunk,hash]")}function processNewMilestone(nodeId){const ui=VVG.graphics.getNodeUI(nodeId);if(ui){Iterators.dfsDirectedIterator(VVG.graph.getNode(nodeId),node=>{processNewConfirmed(node.id)},!1);const node=VVG.graph.getNode(nodeId);node&&(node.milestone=!0,LOG&&console.log("ms found",ui),Styles.update(node))}}function processNewConfirmed(nodeId){const node=VVG.graph.getNode(nodeId);node&&(node.confirmed=!0,Styles.update(node))}function removeNode(nodeID){VVG.graph.removeNode(nodeID)}tangle.on("update",txs=>{for(const tx of txs)addNode(tx)}),tangle.on("remove",txs=>{if(txs&&0!=txs.length)for(const tx of txs)removeNode(tx.hash||tx);else VVG.graph.forEachNode(N=>removeNode(N.id))})})(VVG,tangle,Color,Styles,Graphs,Iterators,UrlParams,Loading);function getGraphBoundingBox(node){const bbx={x1:Number.MAX_VALUE,x2:Number.MIN_VALUE,y1:Number.MAX_VALUE,y2:Number.MIN_VALUE};return Iterators.iterateAllConnectedNodes(node,n=>{const pos=VVG.layout.getNodePosition(n.id);pos.x>bbx.x2&&(bbx.x2=pos.x),pos.x<bbx.x1&&(bbx.x1=pos.x),pos.y>bbx.y2&&(bbx.y2=pos.x),pos.y<bbx.y1&&(bbx.y1=pos.x)}),bbx}setInterval(()=>{Selection.updateActiveNodeSelection(),Styles.update()},3e3);const Options=((CONFIG,Iterators,$container)=>{const $optionContainer=document.createElement("div");$optionContainer.setAttribute("id","options"),$container.appendChild($optionContainer);let OPTIONS={};function createToggleOption(id,name,desc){let listener;$optionContainer.insertAdjacentHTML("beforeend",`<div class="option" data-tooltip="${desc} [${id}]">\n                    <label class="option-label" for="${id}" >\n                        <span>${name}</span>\n                        <input class="tgl tgl-light" id="${id}" type="checkbox" />\n                        <div class="tgl-btn"></div>\n                    </label>\n                </div>`);let initial=!0;const onChange=()=>{},api={onChange:cb=>{listener=cb},set:val=>{listener&&(CONFIG[id]!==val||initial)&&(listener(val),CONFIG[id]=val,document.getElementById(id).checked=!!val,initial=!1)}};return document.getElementById(id).addEventListener("change",event=>{api.set(event.target.checked)}),OPTIONS[id]=api,api}function calculateConfirms(node,confirms,mode){let c=0;Iterators.dfsDirectedIterator(node,()=>{c++},mode),confirms[node.id]=c}let size_filter=!1;function hslToHex(h,s,l){let r,g,b;if(h/=360,l/=100,0===(s/=100))r=g=b=l;else{const hue2rgb=(p,q,t)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p),q=l<.5?l*(1+s):l+s-l*s,p=2*l-q;r=hue2rgb(p,q,h+1/3),g=hue2rgb(p,q,h),b=hue2rgb(p,q,h-1/3)}return(b=~~(255*b))|(g=~~(255*g))<<8|(r=~~(255*r))<<16}createToggleOption("SIZE_BY_DEPTH","size by # of confirms").onChange(function(checked){if(CONFIG.SIZE_BY_VALUE&&OPTIONS.SIZE_BY_VALUE.set(!1),CONFIG.SIZE_BY_WEIGHT&&OPTIONS.SIZE_BY_WEIGHT.set(!1),size_filter&&(Styles.remove(size_filter),size_filter=!1),checked){const confirms={};Graphs.iterateAllNodes(node=>{calculateConfirms(node,confirms,!0)}),size_filter=Styles.add(node=>{confirms.hasOwnProperty(node.id)||calculateConfirms(node,confirms,!0);const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.size=10+confirms[node.id]/VVG.graph.getNodesCount()*80})}}),createToggleOption("SIZE_BY_WEIGHT","size by weight").onChange(function(checked){if(CONFIG.SIZE_BY_VALUE&&OPTIONS.SIZE_BY_VALUE.set(!1),CONFIG.SIZE_BY_DEPTH&&OPTIONS.SIZE_BY_DEPTH.set(!1),size_filter&&(Styles.remove(size_filter),size_filter=!1),checked){const confirms={};Graphs.iterateAllNodes(node=>{calculateConfirms(node,confirms,!1)}),size_filter=Styles.add(node=>{confirms.hasOwnProperty(node.id)||calculateConfirms(node,confirms,!1);const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.size=10+confirms[node.id]/VVG.graph.getNodesCount()*80})}}),createToggleOption("SIZE_BY_VALUE","size by value","").onChange(function(checked){if(CONFIG.SIZE_BY_DEPTH&&OPTIONS.SIZE_BY_DEPTH.set(!1),CONFIG.SIZE_BY_WEIGHT&&OPTIONS.SIZE_BY_WEIGHT.set(!1),size_filter&&(Styles.remove(size_filter),size_filter=!1),checked){let maxVal=0;Graphs.iterateAllNodes(node=>{node.data&&node.data.value&&+node.data.value>maxVal&&(maxVal=+node.data.value)}),LOG&&console.log("maxval",maxVal),size_filter=Styles.add(node=>{node.data&&node.data.value&&node.data.value>maxVal&&Styles.clearCache();const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.size=node.data&&node.data.value?1+Math.sqrt(1+Math.abs(+node.data.value)/maxVal*CONFIG.CIRCLE_SIZE*CONFIG.CIRCLE_SIZE):1})}});let color_by_number_filter=!1;function updateParameter(key,value){OPTIONS.hasOwnProperty(key)&&OPTIONS[key].set(value)}createToggleOption("COLOR_BY_NUMBER","color by order","colors the tx based on the order they were attached").onChange(function(checked){color_by_number_filter&&(Styles.remove(color_by_number_filter),color_by_number_filter=!1),checked&&(color_by_number_filter=Styles.add(node=>{const nodeUI=VVG.graphics.getNodeUI(node.id);nodeUI.border_color=hslToHex(node.number%3600/10,80,50)}))}),createToggleOption("REMOVE_FLOATING_NODES","remove floating tx","floating tx attach to an old, not displayed, part of the tangle").onChange(function(checked){}),createToggleOption("PIN_OLD_NODES","pin old tx","improves performance by not calculating physics").onChange(function(checked){checked||Graphs.unpinOldNodes()}),createToggleOption("REMOVE_OLD_NODES",`limit to ${Format.formatNumber(CONFIG.MAX_NODES)} tx`,"improves performance by removing old tx").onChange(function(checked){}),createToggleOption("SPAWN_NODE_NEAR_FINAL_POSITION","reduce movement","spawning new tx next to their referenced nodes").onChange(function(checked){}),createToggleOption("LIGHT_LINKS","lighten links","").onChange(function(checked){CONFIG.LINK_COLOR=checked?2863311615:CONFIG.DARK_MODE?4008636159:CONFIG.LIGHT_LINK_COLOR,Graphs.iterateAllNodes(!1,link=>Color.colorLink(link))}),createToggleOption("DARK_MODE","dark mode","").onChange(function(checked){CONFIG.LINK_COLOR=checked?4008636159:CONFIG.LIGHT_LINK_COLOR,CONFIG.NODE_COLOR=checked?4008636159:CONFIG.LIGHT_NODE_COLOR,CONFIG.NODE_BG_COLOR=checked?3355443:CONFIG.LIGHT_NODE_BG_COLOR,Graphs.iterateAllNodes(!1,link=>Color.colorLink(link)),Styles.clearCache(),$("body").toggleClass("dark-mode",checked)}),createToggleOption("STATIC_FRONT","center tangle","new tx spawn in the center and tangles moves outwards").onChange(function(checked){checked?VVG.layout.setForce(CONFIG.FORCE):VVG.layout.setForce({x:0,y:0}),$("body").toggleClass("dark-mode",CONFIG.DARK_MODE)}),createToggleOption("PAUSE_RENDERING","freeze tangle","stop node movement for better inspection").onChange(function(checked){checked?VVG.renderer.pause():VVG.renderer.resume()});for(const key in CONFIG)if(CONFIG.hasOwnProperty(key)){const config=CONFIG[key];updateParameter(key,config)}return{updateParameter:updateParameter}})(CONFIG,Iterators,$container),handle=tangle.on("update",()=>{Loading.stop(),handle.remove()});return{updateTx:tx=>{tangle.emit("update",tx)},removeTx:tx=>{tangle.emit("remove",tx)},getTxByHash:VVG.graph.getNode,setNetworkName:UI.setNetworkName,setOption:Options.updateParameter}};